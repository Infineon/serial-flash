<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Serial Flash (serial-flash)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Serial Flash (serial-flash)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group__board__libs.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Serial Flash</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>In addition to the APIs for reading and writting to memory at runtime, this library also provides support for informing programming tools about the external memory so it can be be written at the same time as internal flash. </p>
<p>This support can be enabled by defining CY_ENABLE_XIP_PROGRAM while building the application. With this define in place, code will be generated in the .cy_sflash_user_data &amp; .cy_toc_part2 sections. These locations can be read by programming tools (eg: Cypress Programmer, OpenOCD, pyOCD) to know that there is a memory device attached and how to program it. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabe7c8c3af5cdc0f9640b70402f543dd7"><td class="memItemLeft" align="right" valign="top"><a id="gabe7c8c3af5cdc0f9640b70402f543dd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gabe7c8c3af5cdc0f9640b70402f543dd7">CY_RSLT_SERIAL_FLASH_ERR_UNSUPPORTED</a>&#160;&#160;&#160;(CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_BOARD_LIB_SERIAL_FLASH, 1))</td></tr>
<tr class="memdesc:gabe7c8c3af5cdc0f9640b70402f543dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function or operation is not supported on the target or the memory. <br /></td></tr>
<tr class="separator:gabe7c8c3af5cdc0f9640b70402f543dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa9c587684b8b629a0fde56e786400d82"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gaa9c587684b8b629a0fde56e786400d82">cy_serial_flash_qspi_init</a> (const cy_stc_smif_mem_config_t *mem_config, cyhal_gpio_t io0, cyhal_gpio_t io1, cyhal_gpio_t io2, cyhal_gpio_t io3, cyhal_gpio_t io4, cyhal_gpio_t io5, cyhal_gpio_t io6, cyhal_gpio_t io7, cyhal_gpio_t sclk, cyhal_gpio_t ssel, uint32_t hz)</td></tr>
<tr class="memdesc:gaa9c587684b8b629a0fde56e786400d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the serial flash memory.  <a href="#gaa9c587684b8b629a0fde56e786400d82">More...</a><br /></td></tr>
<tr class="separator:gaa9c587684b8b629a0fde56e786400d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4914a8bff25287d43c661d6cd68fbfd"><td class="memItemLeft" align="right" valign="top"><a id="gac4914a8bff25287d43c661d6cd68fbfd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gac4914a8bff25287d43c661d6cd68fbfd">cy_serial_flash_qspi_deinit</a> (void)</td></tr>
<tr class="memdesc:gac4914a8bff25287d43c661d6cd68fbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the serial flash memory. <br /></td></tr>
<tr class="separator:gac4914a8bff25287d43c661d6cd68fbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9bff94b0c4ba30b11de9f64a0e4980"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga7b9bff94b0c4ba30b11de9f64a0e4980">cy_serial_flash_qspi_get_size</a> (void)</td></tr>
<tr class="memdesc:ga7b9bff94b0c4ba30b11de9f64a0e4980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the serial flash memory in bytes.  <a href="#ga7b9bff94b0c4ba30b11de9f64a0e4980">More...</a><br /></td></tr>
<tr class="separator:ga7b9bff94b0c4ba30b11de9f64a0e4980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaad29bc13d3a4cd243830980b21c274"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gacaad29bc13d3a4cd243830980b21c274">cy_serial_flash_qspi_get_erase_size</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gacaad29bc13d3a4cd243830980b21c274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the erase sector to which the given address belongs.  <a href="#gacaad29bc13d3a4cd243830980b21c274">More...</a><br /></td></tr>
<tr class="separator:gacaad29bc13d3a4cd243830980b21c274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4219e6b1182c0c75704581b6cacc37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga3b4219e6b1182c0c75704581b6cacc37">cy_serial_flash_qspi_get_prog_size</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga3b4219e6b1182c0c75704581b6cacc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page size for programming of the sector to which the given address belongs.  <a href="#ga3b4219e6b1182c0c75704581b6cacc37">More...</a><br /></td></tr>
<tr class="separator:ga3b4219e6b1182c0c75704581b6cacc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aec27b28a9ce3205ce16e12c4d576b0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga1aec27b28a9ce3205ce16e12c4d576b0">cy_serial_flash_get_sector_start_address</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga1aec27b28a9ce3205ce16e12c4d576b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to calculate the starting address of an erase sector to which the given address belongs.  <a href="#ga1aec27b28a9ce3205ce16e12c4d576b0">More...</a><br /></td></tr>
<tr class="separator:ga1aec27b28a9ce3205ce16e12c4d576b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b700333be27d3f22dbf2b7a273e7f1e"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga8b700333be27d3f22dbf2b7a273e7f1e">cy_serial_flash_qspi_read</a> (uint32_t addr, size_t length, uint8_t *buf)</td></tr>
<tr class="memdesc:ga8b700333be27d3f22dbf2b7a273e7f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the serial flash memory.  <a href="#ga8b700333be27d3f22dbf2b7a273e7f1e">More...</a><br /></td></tr>
<tr class="separator:ga8b700333be27d3f22dbf2b7a273e7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e5444e256507f0bc5d112d6741621a"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#gab7e5444e256507f0bc5d112d6741621a">cy_serial_flash_qspi_write</a> (uint32_t addr, size_t length, const uint8_t *buf)</td></tr>
<tr class="memdesc:gab7e5444e256507f0bc5d112d6741621a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data to the serial flash memory.  <a href="#gab7e5444e256507f0bc5d112d6741621a">More...</a><br /></td></tr>
<tr class="separator:gab7e5444e256507f0bc5d112d6741621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c8380588bc01b6a8320b23bc172649"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga41c8380588bc01b6a8320b23bc172649">cy_serial_flash_qspi_erase</a> (uint32_t addr, size_t length)</td></tr>
<tr class="memdesc:ga41c8380588bc01b6a8320b23bc172649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the serial flash memory, uses chip erase command when addr = 0 and length = flash_size otherwise uses sector erase command.  <a href="#ga41c8380588bc01b6a8320b23bc172649">More...</a><br /></td></tr>
<tr class="separator:ga41c8380588bc01b6a8320b23bc172649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56772d2543b7b7f2c17ed9ddb9db941e"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga56772d2543b7b7f2c17ed9ddb9db941e">cy_serial_flash_qspi_enable_xip</a> (bool enable)</td></tr>
<tr class="memdesc:ga56772d2543b7b7f2c17ed9ddb9db941e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables Execute-in-Place (memory mapped) mode on the MCU.  <a href="#ga56772d2543b7b7f2c17ed9ddb9db941e">More...</a><br /></td></tr>
<tr class="separator:ga56772d2543b7b7f2c17ed9ddb9db941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818e617f0abbff49f43ee1254d7bc35c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__board__libs.html#ga818e617f0abbff49f43ee1254d7bc35c">cy_serial_flash_qspi_set_interrupt_priority</a> (uint8_t priority)</td></tr>
<tr class="memdesc:ga818e617f0abbff49f43ee1254d7bc35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes QSPI interrupt priority.  <a href="#ga818e617f0abbff49f43ee1254d7bc35c">More...</a><br /></td></tr>
<tr class="separator:ga818e617f0abbff49f43ee1254d7bc35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa9c587684b8b629a0fde56e786400d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9c587684b8b629a0fde56e786400d82">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_init </td>
          <td>(</td>
          <td class="paramtype">const cy_stc_smif_mem_config_t *&#160;</td>
          <td class="paramname"><em>mem_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>io7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>sclk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cyhal_gpio_t&#160;</td>
          <td class="paramname"><em>ssel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the serial flash memory. </p>
<p>This function accepts up to 8 I/Os. Number of I/Os depend on the type of memory interface. Pass NC when an I/O is unused. Single SPI - (io0, io1) or (io2, io3) or (io4, io5) or (io6, io7) Dual SPI - (io0, io1) or (io2, io3) or (io4, io5) or (io6, io7) Quad SPI - (io0, io1, io2, io3) or (io4, io5, io6, io7) Octal SPI - All 8 I/Os are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_config</td><td>Memory configuration to be used for initializing </td></tr>
    <tr><td class="paramname">io0</td><td>Data/IO pin 0 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io1</td><td>Data/IO pin 1 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io2</td><td>Data/IO pin 2 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io3</td><td>Data/IO pin 3 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io4</td><td>Data/IO pin 4 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io5</td><td>Data/IO pin 5 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io6</td><td>Data/IO pin 6 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">io7</td><td>Data/IO pin 7 connected to the memory, Pass NC when unused. </td></tr>
    <tr><td class="paramname">sclk</td><td>Clock pin connected to the memory </td></tr>
    <tr><td class="paramname">ssel</td><td>Slave select pin connected to the memory </td></tr>
    <tr><td class="paramname">hz</td><td>Clock frequency to be used with the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the initialization was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga7b9bff94b0c4ba30b11de9f64a0e4980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b9bff94b0c4ba30b11de9f64a0e4980">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cy_serial_flash_qspi_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the serial flash memory in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Memory size in bytes. </dd></dl>

</div>
</div>
<a id="gacaad29bc13d3a4cd243830980b21c274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaad29bc13d3a4cd243830980b21c274">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_get_erase_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cy_serial_flash_qspi_get_erase_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the erase sector to which the given address belongs. </p>
<p>Address is used only for a memory with hybrid sector size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address that belongs to the sector for which size is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Erase sector size in bytes. </dd></dl>

</div>
</div>
<a id="ga3b4219e6b1182c0c75704581b6cacc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4219e6b1182c0c75704581b6cacc37">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_get_prog_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cy_serial_flash_qspi_get_prog_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the page size for programming of the sector to which the given address belongs. </p>
<p>Address is used only for a memory with hybrid sector size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address that belongs to the sector for which size is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Page size in bytes. </dd></dl>

</div>
</div>
<a id="ga1aec27b28a9ce3205ce16e12c4d576b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aec27b28a9ce3205ce16e12c4d576b0">&#9670;&nbsp;</a></span>cy_serial_flash_get_sector_start_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t cy_serial_flash_get_sector_start_address </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to calculate the starting address of an erase sector to which the given address belongs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address in the sector for which the starting address is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Starting address of the sector </dd></dl>

</div>
</div>
<a id="ga8b700333be27d3f22dbf2b7a273e7f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b700333be27d3f22dbf2b7a273e7f1e">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the serial flash memory. </p>
<p>This is a blocking function. Returns error if (addr + length) exceeds the flash size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Starting address to read from </td></tr>
    <tr><td class="paramname">length</td><td>Number of data bytes to read </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the buffer to store the data read from the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the read was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="gab7e5444e256507f0bc5d112d6741621a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e5444e256507f0bc5d112d6741621a">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the data to the serial flash memory. </p>
<p>The program area must have been erased prior to calling this API using <a class="el" href="group__group__board__libs.html#ga41c8380588bc01b6a8320b23bc172649">cy_serial_flash_qspi_erase()</a> This is a blocking function. Returns error if (addr + length) exceeds the flash size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Starting address to write to </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to write </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to the buffer storing the data to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the write was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga41c8380588bc01b6a8320b23bc172649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c8380588bc01b6a8320b23bc172649">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_erase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the serial flash memory, uses chip erase command when addr = 0 and length = flash_size otherwise uses sector erase command. </p>
<p>This is a blocking function. Returns error if addr or (addr + length) is not aligned to the sector size or if (addr + length) exceeds the flash size. Call <a class="el" href="group__group__board__libs.html#ga7b9bff94b0c4ba30b11de9f64a0e4980">cy_serial_flash_qspi_get_size()</a> to get the flash size and call <a class="el" href="group__group__board__libs.html#gacaad29bc13d3a4cd243830980b21c274">cy_serial_flash_qspi_get_erase_size()</a> to get the size of an erase sector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Starting address to begin erasing </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the erase was successful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga56772d2543b7b7f2c17ed9ddb9db941e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56772d2543b7b7f2c17ed9ddb9db941e">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_enable_xip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t cy_serial_flash_qspi_enable_xip </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables Execute-in-Place (memory mapped) mode on the MCU. </p>
<p>This function does not send any command to the serial flash. This may not be supported on all the targets in which case CY_RSLT_SERIAL_FLASH_ERR_UNSUPPORTED is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true: XIP mode is set, false: normal mode is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the operation was successful. CY_RSLT_SERIAL_FLASH_ERR_UNSUPPORTED if the target does not support XIP. </dd></dl>

</div>
</div>
<a id="ga818e617f0abbff49f43ee1254d7bc35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818e617f0abbff49f43ee1254d7bc35c">&#9670;&nbsp;</a></span>cy_serial_flash_qspi_set_interrupt_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cy_serial_flash_qspi_set_interrupt_priority </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes QSPI interrupt priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>interrupt priority to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Serial Flash (serial-flash)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
